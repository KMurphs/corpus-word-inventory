{"ast":null,"code":"import _objectSpread from\"C:\\\\PersonalProjects\\\\corpus-word-inventory\\\\book-inventory-ui\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";var httpRequest=function httpRequest(_url,parameters){var method=arguments.length>2&&arguments[2]!==undefined?arguments[2]:\"GET\";var headers=arguments.length>3?arguments[3]:undefined;var _header={'content-type':'application/json'};var url=_url;// Build generic options for fetch api\nvar options={method:method,headers:_objectSpread({},_header,{},headers)// mode: 'no-cors'\n};// Process Parameters/body\nif(parameters){switch(method.toLowerCase()){case'get':// Build Request parameters in url \n// Filter parameters to get non empty items on object\nvar keys=Object.keys(parameters);var validParams=Object.values(parameters).reduce(function(acc,item,index){item&&(acc[keys[index]]=item);return acc;},{});// If parameters are not empty, append to url\nif(Object.values(validParams).join(\"\")){url=url+Object.keys(validParams).reduce(function(acc,key,index){return\"\".concat(acc).concat(index===0?'?':'&').concat(key,\"=\").concat(validParams[key]);},'');}break;default:// By default parameters will become the json body of the request\noptions[\"body\"]=JSON.stringify(parameters);break;}}console.log(\"[fetch] Fetching at '\".concat(url,\"' with options '\").concat(JSON.stringify(options),\"'\"));return new Promise(function(resolve,reject){fetch(url,options)// fakeFetch(url, options)\n.then(function(res){return res.json();}).then(function(data){return resolve(data);}).catch(function(err){return reject(err);});});};export default httpRequest;","map":{"version":3,"sources":["C:/PersonalProjects/corpus-word-inventory/book-inventory-ui/src/data.controller/utils/data.fetch.ts"],"names":["httpRequest","_url","parameters","method","headers","_header","url","options","toLowerCase","keys","Object","validParams","values","reduce","acc","item","index","join","key","JSON","stringify","console","log","Promise","resolve","reject","fetch","then","res","json","data","catch","err"],"mappings":"mJACA,GAAMA,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CACEC,IADF,CAEEC,UAFF,CAIuC,IADrCC,CAAAA,MACqC,2DADpB,KACoB,IAArCC,CAAAA,OAAqC,2CAGzD,GAAIC,CAAAA,OAAO,CAAG,CAAC,eAAgB,kBAAjB,CAAd,CACA,GAAIC,CAAAA,GAAW,CAAGL,IAAlB,CAMA;AACA,GAAIM,CAAAA,OAAY,CAAG,CACjBJ,MAAM,CAAEA,MADS,CAEjBC,OAAO,kBAAMC,OAAN,IAAkBD,OAAlB,CACP;AAHiB,CAAnB,CAUA;AACA,GAAGF,UAAH,CAAc,CACZ,OAAOC,MAAM,CAACK,WAAP,EAAP,EACE,IAAK,KAAL,CAEE;AACA;AACA,GAAMC,CAAAA,IAAI,CAAGC,MAAM,CAACD,IAAP,CAAYP,UAAZ,CAAb,CACA,GAAMS,CAAAA,WAAW,CAAGD,MAAM,CAACE,MAAP,CAAcV,UAAd,EACOW,MADP,CACc,SAACC,GAAD,CAAMC,IAAN,CAAYC,KAAZ,CAAsB,CAC1BD,IAAI,GAAKD,GAAG,CAACL,IAAI,CAACO,KAAD,CAAL,CAAH,CAAmBD,IAAxB,CAAJ,CACA,MAAOD,CAAAA,GAAP,CACD,CAJT,CAKQ,EALR,CAApB,CAMA;AACA,GAAGJ,MAAM,CAACE,MAAP,CAAcD,WAAd,EAA2BM,IAA3B,CAAgC,EAAhC,CAAH,CAAuC,CACrCX,GAAG,CAAGA,GAAG,CAAGI,MAAM,CAACD,IAAP,CAAYE,WAAZ,EAAyBE,MAAzB,CAAgC,SAACC,GAAD,CAAMI,GAAN,CAAWF,KAAX,kBAAwBF,GAAxB,SAA8BE,KAAK,GAAG,CAAR,CAAU,GAAV,CAAc,GAA5C,SAAkDE,GAAlD,aAAyDP,WAAW,CAACO,GAAD,CAApE,GAAhC,CAA6G,EAA7G,CAAZ,CACD,CAED,MACF,QACE;AACAX,OAAO,CAAC,MAAD,CAAP,CAAkBY,IAAI,CAACC,SAAL,CAAelB,UAAf,CAAlB,CACA,MArBJ,CAuBD,CAEDmB,OAAO,CAACC,GAAR,gCAAoChB,GAApC,4BAA0Da,IAAI,CAACC,SAAL,CAAeb,OAAf,CAA1D,OAKA,MAAO,IAAIgB,CAAAA,OAAJ,CAAY,SAACC,OAAD,CAAUC,MAAV,CAAqB,CACtCC,KAAK,CAACpB,GAAD,CAAMC,OAAN,CACL;AADA,CAECoB,IAFD,CAEM,SAAAC,GAAG,QAAIA,CAAAA,GAAG,CAACC,IAAJ,EAAJ,EAFT,EAGCF,IAHD,CAGM,SAAAG,IAAI,QAAEN,CAAAA,OAAO,CAACM,IAAD,CAAT,EAHV,EAICC,KAJD,CAIO,SAAAC,GAAG,QAAIP,CAAAA,MAAM,CAACO,GAAD,CAAV,EAJV,EAKD,CANM,CAAP,CASD,CAlED,CAqEA,cAAehC,CAAAA,WAAf","sourcesContent":["\r\nconst httpRequest = (\r\n                      _url: string, \r\n                      parameters?: {[key: string]:any},\r\n                      method: string = \"GET\",\r\n                      headers?: {[key:string]: string}) => {\r\n\r\n  \r\n  let _header = {'content-type': 'application/json'}\r\n  let url: string = _url;\r\n\r\n\r\n\r\n  \r\n\r\n  // Build generic options for fetch api\r\n  let options: any = {\r\n    method: method,\r\n    headers: {..._header, ...headers},\r\n    // mode: 'no-cors'\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n  // Process Parameters/body\r\n  if(parameters){\r\n    switch(method.toLowerCase()){\r\n      case 'get':\r\n        \r\n        // Build Request parameters in url \r\n        // Filter parameters to get non empty items on object\r\n        const keys = Object.keys(parameters)\r\n        const validParams = Object.values(parameters)\r\n                                  .reduce((acc, item, index) => {\r\n                                      item && (acc[keys[index]] = item);\r\n                                      return acc;\r\n                                    }\r\n                                  , {})\r\n        // If parameters are not empty, append to url\r\n        if(Object.values(validParams).join(\"\")){\r\n          url = url + Object.keys(validParams).reduce((acc, key, index) => `${acc}${index===0?'?':'&'}${key}=${validParams[key]}`, '')\r\n        }\r\n                                  \r\n        break;\r\n      default:\r\n        // By default parameters will become the json body of the request\r\n        options[\"body\"] = JSON.stringify(parameters)\r\n        break\r\n    }\r\n  }\r\n\r\n  console.log(`[fetch] Fetching at '${url}' with options '${JSON.stringify(options)}'`)\r\n\r\n\r\n\r\n\r\n  return new Promise((resolve, reject) => {\r\n    fetch(url, options)\r\n    // fakeFetch(url, options)\r\n    .then(res => res.json())\r\n    .then(data=>resolve(data))\r\n    .catch(err => reject(err));\r\n  })\r\n\r\n  \r\n}\r\n\r\n\r\nexport default httpRequest;\r\n"]},"metadata":{},"sourceType":"module"}